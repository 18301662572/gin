



## 1.分布式消息队列 NSQ 和 Kafka 对比

[[https://www.liuin.cn/2018/07/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-NSQ-%E5%92%8C-Kafka-%E5%AF%B9%E6%AF%94/](https://www.liuin.cn/2018/07/11/分布式消息队列-NSQ-和-Kafka-对比/)]

### 消息队列的作用

1. 解耦，将一个流程加入一层数据接口拆分成两个部分，上游专注通知，下游专注处理
2. 缓冲，应对流量的突然上涨变更，消息队列有很好的缓冲削峰作用
3. 异步，上游发送消息以后可以马上返回，处理工作交给下游进行
4. 广播，让一个消息被多个下游进行处理
5. 冗余，保存处理的消息，防止消息处理失败导致的数据丢失

**1.相同**
	都是消息队列
**2.不同**
	NSQ自带lookup服务，方便集群下部署拓展，kafka则需要zookeeper配合服务发现
	NSQ用golang实现，kafka用java实现，语言不同
	NSQ中consumer是被动接受消息，kafka可以主动选择消费类型
	NSQ消息是无序的，kafka消息是有序的
	NSQ消息默认储存在内存中，只有超过–mem-queue-size才会存储到硬盘中，kafka默认存储在硬盘	中

**3.对比**

 **a. 存储**

- NSQ 默认是把消息放到内存中，只有当队列里消息的数量超过–mem-queue-size配置的限制时，才会对消息进行持久化。
- Kafka 会把写到磁盘中进行持久化，并通过顺序读写磁盘来保障性能。持久化能够让Kafka做更多的事情：消息的重新消费（重置offset）；让数据更加安全，不那么容易丢失。同时Kafka还通过partition的机制，对消息做了备份，进一步增强了消息的安全性。

  **b.推拉模型**

- NSQ 使用的是推模型，推模型能够使得时延非常小，消息到了马上就能够推送给下游消费，但是下游消费能够无法控制，推送过快可能导致下游过载。
- Kafka 使用的拉模型，拉模型能够让消费者自己掌握节奏，但是这样轮询会让整个消费的时延增加，不过消息队列本身对时延的要求不是很大，这一点影响不是很大。

  **c.消息的顺序性**

- NSQ 因为不能够把特性消息和消费者对应起来，所以无法实现消息的有序性。
- Kafka 因为消息在Partition中写入是有序的，同时一个Partition只能够被 Consumer Group 中的一个Consumer消费，这样就可能实现消息在Partition中的有序。自定义写入哪个Partition的规则能够让需要有序消费的相关消息都进入同一个Partition中被消费，这样达到”全局有序“

### 2.kafka跟nsq（消息队列）业务场景有啥不一样的？



## 3.内联函数？？

内联函数：执行权不转交给被调用函数，而是将函数的代码粘贴在调用处

**goroutine是协程的go语言实现，相当于把别的语言的类库的功能内置到语言里。**



## 4.请求报文，请求消费体？？



## 5.RPC框架？？--微服务框架



## 6.reflect 含义，反射的使用？？？反射在微服务中的应用



## 7.什么是函数原型？？

​		 **函数原型是指由函数定义中抽取出来的能代表函数应用特征的部分，包括函数的数据类型、函数名称、形式参数说明。**



## 8.consul ？？ 服务发现？？  微服务网关？？



## 9.user.proto 与 user.ext.proto 的区别？？